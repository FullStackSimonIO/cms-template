---
title: 'Figma zu Payload - Master Workflow'
description: 'Kompletter Workflow: Figma Design Analyse â†’ Navbar â†’ Footer â†’ Heroes â†’ Blocks. ALLE Komponenten werden korrekt erkannt und kategorisiert.'
alwaysApply: true
---

## ðŸŽ¯ Ziel
VollstÃ¤ndiger Workflow von Figma-Design zu PayloadCMS mit korrekter Kategorisierung:
- **Navbar-Komponenten** â†’ Globals (Mobile + Desktop getrennt)
- **Footer-Komponenten** â†’ Globals (Mobile + Desktop getrennt)  
- **Header-Komponenten** â†’ Heroes unter `/src/heroes/` (mit conditional fields)
- **Alle anderen** â†’ PayloadCMS Blocks unter `/src/blocks/`

---

## ðŸ“‹ Workflow-Schritte

### Phase 1: Figma Check & Design-Analyse
```bash
âœ… Schritt 1: Figma-Verbindung prÃ¼fen
âœ… Schritt 2: ALLE Komponenten erfassen (keine AusschlÃ¼sse!)
âœ… Schritt 3: Intelligente Kategorisierung
```

**Was passiert:**
- Figma MCP-Verbindung testen
- Komplettes Figma-File scannen (rekursiv alle Ebenen)
- ALLE Komponenten erfassen (FRAME, COMPONENT, INSTANCE, etc.)
- Kategorisierung nach Namen-Pattern:
  - `/nav(bar)?|navigation|menu/i` â†’ **Navbar**
  - `/footer|fuÃŸzeile/i` â†’ **Footer**
  - `/header|hero|banner/i` â†’ **Hero**
  - Alle anderen â†’ **Blocks** (nach Kategorie)

**Output:**
- `FIGMA_INVENTORY.json` mit vollstÃ¤ndiger Kategorisierung
- `FIGMA_COMPONENTS_CATEGORIZED.md` (Ãœbersicht)

---

### Phase 2: Design Rework
```bash
âœ… Schritt 4: Farben & Fonts aus Figma extrahieren
âœ… Schritt 5: globals.css anpassen
âœ… Schritt 6: tailwind.config.ts aktualisieren
```

**Was passiert:**
- Design-Tokens aus Figma analysieren
- Farben â†’ Tailwind CSS Variables (background, foreground, primary, etc.)
- Fonts â†’ `src/app/fonts.ts` (Heading + Paragraph)
- Typografie-Skala â†’ globals.css
- Spacing, Border-Radius â†’ tailwind.config.ts

**Output:**
- Aktualisierte `globals.css`
- Aktualisierte `tailwind.config.mjs`
- `src/app/fonts.ts` (falls nicht vorhanden)

---

### Phase 3: Button Design
```bash
âœ… Schritt 7: Button-Komponente aus Figma erstellen
```

**Was passiert:**
- Suche Button-Komponenten in Figma
- Analysiere Varianten (Primary, Secondary, Ghost, Outline)
- Extrahiere Styles (Farben, Padding, Border-Radius, Hover-States)
- Generiere `src/components/ui/button.tsx` mit allen Varianten
- Integriere mit CMSLink-Komponente

**Output:**
- Aktualisierte `src/components/ui/button.tsx` mit Figma-Styles

---

### Phase 4: Navbar-Generierung
```bash
âœ… Schritt 8: Navbar aus Figma analysieren
âœ… Schritt 9: DesktopNavbar.tsx erstellen
âœ… Schritt 10: MobileNavbar.tsx erstellen
âœ… Schritt 11: Navbar Global Config erstellen
```

**Was passiert:**
- Finde Navbar-Komponenten in FIGMA_INVENTORY.json
- Analysiere Layout (Logo-Position, Menu-Items, CTAs, Quick-Links)
- Mappe zu Relume-Template (falls vorhanden)
- Generiere zwei Komponenten:
  - `src/Header/DesktopNav/index.tsx` (horizontale Navigation)
  - `src/Header/MobileNav/index.tsx` (Hamburger-Menu mit Slide-In)
- Erstelle `src/Header/config.ts` (Payload Global Config auf Deutsch)
- Registriere in `payload.config.ts` unter `globals`

**Output:**
- `src/Header/DesktopNav/index.tsx`
- `src/Header/MobileNav/index.tsx`
- `src/Header/config.ts`
- Navbar registriert in PayloadCMS

---

### Phase 5: Footer-Generierung
```bash
âœ… Schritt 12: Footer aus Figma analysieren
âœ… Schritt 13: DesktopFooter.tsx erstellen
âœ… Schritt 14: MobileFooter.tsx erstellen
âœ… Schritt 15: Footer Global Config erstellen
```

**Was passiert:**
- Finde Footer-Komponenten in FIGMA_INVENTORY.json
- Analysiere Layout (Spalten, Social-Links, Copyright, etc.)
- Mappe zu Relume-Template (falls vorhanden)
- Generiere zwei Komponenten:
  - `src/Footer/DesktopFooter/index.tsx`
  - `src/Footer/MobileFooter/index.tsx`
- Erstelle `src/Footer/config.ts` (Payload Global Config auf Deutsch)
- Registriere in `payload.config.ts` unter `globals`

**Output:**
- `src/Footer/DesktopFooter/index.tsx`
- `src/Footer/MobileFooter/index.tsx`
- `src/Footer/config.ts`
- Footer registriert in PayloadCMS

---

### Phase 6: Hero-Generierung
```bash
âœ… Schritt 16: Header-Komponenten aus Figma analysieren
âœ… Schritt 17: Hero-Typen bestimmen
âœ… Schritt 18: Hero-Komponenten generieren
âœ… Schritt 19: Zentrale Hero-Config mit conditional fields
âœ… Schritt 20: RenderHero.tsx erstellen
```

**Was passiert:**
- Finde Header/Hero-Komponenten in FIGMA_INVENTORY.json
- Analysiere Struktur jeder Hero (Bilder, Texte, Buttons, Forms, etc.)
- Bestimme Hero-Typ:
  - `heroSimple` - Nur Text
  - `heroWithImage` - Text + 1 Bild + CTAs
  - `heroWithGallery` - Text + mehrere Bilder
  - `heroWithFeatures` - Text + Feature-Liste
  - `heroWithForm` - Text + Formular
  - `heroWithVideo` - Text + Video
  - `heroSplitScreen` - Text + 2 Bilder
- Generiere fÃ¼r jede Hero:
  - `src/heros/Hero1/index.tsx` (React-Komponente)
- Generiere zentrale Config:
  - `src/heros/config.ts` mit **conditional fields**
  - Felder erscheinen basierend auf ausgewÃ¤hltem Hero-Typ
- Generiere Renderer:
  - `src/heros/RenderHero.tsx` (Hero-Type â†’ Komponente Mapping)
- Integriere in Pages Collection

**Output:**
- `src/heros/Hero1/index.tsx`, `Hero2/index.tsx`, etc.
- `src/heros/config.ts` (mit conditional fields)
- `src/heros/RenderHero.tsx`
- Hero-Field in Pages Collection integriert

**Admin-Panel Verhalten:**
```
Pages â†’ Hero Section â†’ Hero-Typ auswÃ¤hlen
â†’ Je nach Auswahl erscheinen unterschiedliche Felder!

Beispiel:
- WÃ¤hle "Hero1" â†’ Zeigt: Titel, Beschreibung, Bild, 2 Buttons
- WÃ¤hle "Hero2" â†’ Zeigt: Titel, Beschreibung, Galerie, 1 Button
- WÃ¤hle "Hero3" â†’ Zeigt: Titel, Features-Liste, Formular
```

---

### Phase 7: Block-Generierung
```bash
âœ… Schritt 21: Verbleibende Komponenten filtern
âœ… Schritt 22: Blocks generieren (nach Kategorie)
âœ… Schritt 23: Zentrale Registrierung
âœ… Schritt 24: PageRenderer aktualisieren
```

**Was passiert:**
- Filtere aus FIGMA_INVENTORY.json:
  - **NICHT** Navbar-Komponenten (bereits als Global)
  - **NICHT** Footer-Komponenten (bereits als Global)
  - **NICHT** Header/Hero-Komponenten (bereits unter /heroes/)
  - **NUR** die verbleibenden Komponenten
- Gruppiere nach Kategorie (Layout, CTA, Contact, Testimonials, etc.)
- Generiere fÃ¼r jede Komponente:
  - `src/blocks/{Category}/{BlockName}/Component.tsx`
  - `src/blocks/{Category}/{BlockName}/config.ts`
  - `src/blocks/{Category}/{BlockName}/index.ts`
- Basis: Relume-Template aus `relume/{Category}/{ComponentName}/`
- Anpassung: Styles aus Figma-Komponente
- Zentrale Registrierung:
  - `src/blocks/index.ts` (alle Exports)
  - `src/collections/Pages/config.ts` (Blocks-Array)
  - `src/components/PageRenderer/index.tsx` (Component-Mapping)

**Output:**
- Alle Blocks unter `src/blocks/{Category}/{BlockName}/`
- Zentrale `src/blocks/index.ts`
- Aktualisierte Pages Collection
- Aktualisierter PageRenderer

---

## ðŸ”„ VollstÃ¤ndiger Workflow

### Automatischer Ablauf:

```typescript
// 1. Figma Check
await checkFigmaConnection()
await fetchAllFigmaComponents() // ALLE Komponenten, keine AusschlÃ¼sse!
await categorizeFigmaComponents() // Intelligente Kategorisierung

// 2. Design Rework
await extractDesignTokens()
await updateGlobalsCss()
await updateTailwindConfig()

// 3. Button Design
await generateButtonComponent()

// 4. Navbar
const navbarComponents = inventory.categorized.Navbar
await generateDesktopNav(navbarComponents[0])
await generateMobileNav(navbarComponents[0])
await generateNavbarConfig()
await registerNavbarGlobal()

// 5. Footer
const footerComponents = inventory.categorized.Footer
await generateDesktopFooter(footerComponents[0])
await generateMobileFooter(footerComponents[0])
await generateFooterConfig()
await registerFooterGlobal()

// 6. Heroes
const heroComponents = inventory.categorized.Hero
for (const hero of heroComponents) {
  const heroType = analyzeHeroStructure(hero)
  await generateHeroComponent(hero, heroType)
}
await generateHeroConfig(heroComponents) // Mit conditional fields!
await generateRenderHero(heroComponents)
await integrateHeroInPages()

// 7. Blocks (alle verbleibenden Komponenten)
const blockComponents = inventory.categorized.filter(
  cat => !['Navbar', 'Footer', 'Hero'].includes(cat)
)
for (const [category, components] of blockComponents) {
  for (const comp of components) {
    await generateBlock(category, comp)
  }
}
await generateCentralExports()
await registerBlocksInPages()
await updatePageRenderer()

// 8. Validierung
await validateTypeScript()
await buildProject()
await generateDocumentation()
```

---

## ðŸ“Š Erwartete Komponenten-Verteilung

**Typisches Projekt:**

```
FIGMA_INVENTORY.json:
{
  "meta": {
    "totalComponents": 45-80
  },
  "categorized": {
    "Navbar": [1-2],     â†’ Globals (Mobile + Desktop)
    "Footer": [1-2],     â†’ Globals (Mobile + Desktop)
    "Hero": [3-8],       â†’ /src/heroes/ (mit conditional fields)
    "Layout": [10-20],   â†’ Blocks
    "CTA": [3-8],        â†’ Blocks
    "Contact": [2-4],    â†’ Blocks
    "Testimonials": [2-3], â†’ Blocks
    "Pricing": [1-2],    â†’ Blocks
    "Gallery": [2-4],    â†’ Blocks
    "Team": [1-2],       â†’ Blocks
    "FAQ": [1-2],        â†’ Blocks
    "Weitere": [5-15]    â†’ Blocks
  }
}
```

**Generierte Struktur:**

```
src/
â”œâ”€â”€ Header/
â”‚   â”œâ”€â”€ DesktopNav/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â”œâ”€â”€ MobileNav/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â””â”€â”€ config.ts (Global Config)
â”‚
â”œâ”€â”€ Footer/
â”‚   â”œâ”€â”€ DesktopFooter/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â”œâ”€â”€ MobileFooter/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â””â”€â”€ config.ts (Global Config)
â”‚
â”œâ”€â”€ heros/
â”‚   â”œâ”€â”€ Hero1/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â”œâ”€â”€ Hero2/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â”œâ”€â”€ Hero3/
â”‚   â”‚   â””â”€â”€ index.tsx
â”‚   â”œâ”€â”€ config.ts (mit conditional fields!)
â”‚   â””â”€â”€ RenderHero.tsx
â”‚
â””â”€â”€ blocks/
    â”œâ”€â”€ Layout/
    â”‚   â”œâ”€â”€ Layout1/
    â”‚   â”‚   â”œâ”€â”€ Component.tsx
    â”‚   â”‚   â”œâ”€â”€ config.ts
    â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â””â”€â”€ ... (10-20 Blocks)
    â”œâ”€â”€ CTA/
    â”‚   â””â”€â”€ ... (3-8 Blocks)
    â”œâ”€â”€ Contact/
    â”‚   â””â”€â”€ ... (2-4 Blocks)
    â””â”€â”€ ... (weitere Kategorien)
    â””â”€â”€ index.ts (zentrale Exports)
```

---

## âœ… Checkliste - VollstÃ¤ndigkeit

Nach Workflow-Durchlauf prÃ¼fen:

### Figma-Erfassung:
- [ ] ALLE Komponenten erfasst (keine AusschlÃ¼sse)
- [ ] Navbar-Komponenten erkannt
- [ ] Footer-Komponenten erkannt
- [ ] Header/Hero-Komponenten erkannt
- [ ] Alle anderen Komponenten erkannt

### Design:
- [ ] globals.css aktualisiert
- [ ] tailwind.config.ts aktualisiert
- [ ] Fonts importiert
- [ ] Button-Komponente erstellt

### Navbar:
- [ ] DesktopNav generiert
- [ ] MobileNav generiert
- [ ] Navbar Global Config erstellt
- [ ] In payload.config.ts registriert
- [ ] Im Admin-Panel sichtbar

### Footer:
- [ ] DesktopFooter generiert
- [ ] MobileFooter generiert
- [ ] Footer Global Config erstellt
- [ ] In payload.config.ts registriert
- [ ] Im Admin-Panel sichtbar

### Heroes:
- [ ] Alle Header-Komponenten als Heroes generiert
- [ ] Hero-Typen korrekt erkannt
- [ ] Conditional Fields Config erstellt
- [ ] RenderHero.tsx generiert
- [ ] In Pages Collection integriert
- [ ] Im Admin-Panel: Felder Ã¤ndern sich bei Hero-Typ-Auswahl

### Blocks:
- [ ] Alle verbleibenden Komponenten als Blocks generiert
- [ ] Keine Duplikate (Navbar, Footer, Heroes bereits generiert)
- [ ] Zentrale index.ts erstellt
- [ ] Pages Collection aktualisiert
- [ ] PageRenderer aktualisiert

### Validierung:
- [ ] TypeScript: `npm run type-check` âœ…
- [ ] Build: `npm run build` âœ…
- [ ] Dev-Server: `npm run dev` âœ…
- [ ] Admin-Panel: Alle Komponenten sichtbar âœ…

---

## ðŸš€ Verwendung

**FÃ¼hre diesen Master-Command aus:**

```bash
cursor> Figma zu Payload - Master Workflow
```

**Oder Schritt-fÃ¼r-Schritt:**

```bash
# 1. Figma Check
cursor> Check Figma Design

# 2. Design Rework  
cursor> Design Rework from Figma

# 3. Button Design
cursor> Style Buttons from Figma

# 4. Navbar
cursor> Build Navbar from Figma

# 5. Footer
cursor> Build Footer from Figma

# 6. Heroes
cursor> Generate Heroes from Figma

# 7. Blocks
cursor> Generate Blocks from Figma
```

---

## ðŸŽ¯ Erfolgskriterien

Nach vollstÃ¤ndigem Workflow:

âœ… **ALLE** Figma-Komponenten korrekt kategorisiert  
âœ… **Navbar** als Global (Mobile + Desktop getrennt)  
âœ… **Footer** als Global (Mobile + Desktop getrennt)  
âœ… **Heroes** unter /src/heroes/ mit conditional fields  
âœ… **Blocks** unter /src/blocks/ (alle anderen Komponenten)  
âœ… **Admin-Panel** zeigt alle Komponenten korrekt  
âœ… **TypeScript** fehlerfrei  
âœ… **Build** erfolgreich  

---

## ðŸ’¡ Wichtige Hinweise

### Kategorisierung ist kritisch:
- **KEINE** manuellen AusschlÃ¼sse
- Pattern-Matching fÃ¼r Navbar: `/nav(bar)?|navigation|menu/i`
- Pattern-Matching fÃ¼r Footer: `/footer|fuÃŸzeile/i`
- Pattern-Matching fÃ¼r Heroes: `/header|hero|banner/i`
- Alle anderen â†’ Blocks nach Kategorie

### Conditional Fields bei Heroes:
- Hero-Typ bestimmt sichtbare Felder
- Implementiert Ã¼ber `admin.condition` in Payload
- Beispiel: Form-Felder nur bei `heroWithForm` sichtbar

### Mobile + Desktop getrennt:
- Navbar: 2 Komponenten (DesktopNav, MobileNav)
- Footer: 2 Komponenten (DesktopFooter, MobileFooter)
- Responsive Breakpoints aus Figma Ã¼bernehmen
- Beide Komponenten in einer Global Config

---

âœ… **VollstÃ¤ndiger Workflow fÃ¼r perfekte Figma â†’ PayloadCMS Transformation!**
