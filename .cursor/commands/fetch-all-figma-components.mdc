---
title: 'Fetch ALL Figma Components'
description: 'Systematische Erfassung ALLER Komponenten aus dem verbundenen Figma-File, ohne Ausschl√ºsse oder Limitierungen.'
alwaysApply: true
---

## üéØ Ziel
Erfasse VOLLST√ÑNDIG alle Komponenten, Frames und Elemente aus dem Figma-File √ºber die MCP-Integration.

---

## üîç VOLLST√ÑNDIGE FIGMA-ERFASSUNG

### Phase 1: Figma-Verbindung pr√ºfen

```typescript
// 1. Teste MCP-Verbindung
const figmaConnection = await mcp.testConnection()

if (!figmaConnection.success) {
  throw new Error('‚ùå Figma MCP Server nicht erreichbar')
}

console.log('‚úÖ Figma MCP Server verbunden')
console.log(`   - File Key: ${FIGMA_FILE_KEY}`)
console.log(`   - Access Token: ${FIGMA_ACCESS_TOKEN ? '‚úì' : '‚úó'}`)
```

---

### Phase 2: Vollst√§ndiger File-Scan

```typescript
// 2. Lade GESAMTES Figma-File (nicht nur Seiten)
const figmaFile = await mcp.getFigmaFile({
  fileKey: FIGMA_FILE_KEY,
  depth: 'full', // Rekursiv alle Ebenen
  includeComponents: true,
  includeInstances: true,
  includeStyles: true,
  includeVariables: true,
})

console.log('üìä Figma-File geladen:')
console.log(`   - Name: ${figmaFile.name}`)
console.log(`   - Version: ${figmaFile.version}`)
console.log(`   - Last Modified: ${figmaFile.lastModified}`)
```

---

### Phase 3: Komponenten-Inventar erstellen

```typescript
// 3. Extrahiere ALLE Komponenten (ohne Filter!)
const allComponents = []

// Durchlaufe ALLE Seiten
for (const page of figmaFile.document.children) {
  console.log(`\nüìÑ Scanne Seite: ${page.name}`)
  
  // Rekursive Funktion f√ºr alle Ebenen
  function extractComponents(node, depth = 0, parentPath = []) {
    const currentPath = [...parentPath, node.name]
    
    // Erfasse JEDEN Node-Typ
    const component = {
      id: node.id,
      name: node.name,
      type: node.type,
      page: page.name,
      path: currentPath.join(' > '),
      depth: depth,
      
      // Metadata
      visible: node.visible !== false,
      locked: node.locked === true,
      
      // Layout & Styling
      absoluteBoundingBox: node.absoluteBoundingBox,
      constraints: node.constraints,
      layoutMode: node.layoutMode,
      
      // Figma-spezifisch
      componentId: node.componentId,
      componentSetId: node.componentSetId,
      
      // Children-Count
      childrenCount: node.children?.length || 0,
    }
    
    allComponents.push(component)
    
    // Rekursiv f√ºr alle Kinder
    if (node.children && node.children.length > 0) {
      for (const child of node.children) {
        extractComponents(child, depth + 1, currentPath)
      }
    }
  }
  
  // Starte Extraktion f√ºr diese Seite
  extractComponents(page, 0, [page.name])
}

console.log(`\n‚úÖ ${allComponents.length} Komponenten erfasst!`)
```

---

### Phase 4: Kategorisierung

```typescript
// 4. Kategorisiere Komponenten nach Typ
const categorized = {
  // Figma Node-Typen
  FRAME: [],
  COMPONENT: [],
  COMPONENT_SET: [],
  INSTANCE: [],
  GROUP: [],
  TEXT: [],
  RECTANGLE: [],
  ELLIPSE: [],
  VECTOR: [],
  LINE: [],
  BOOLEAN_OPERATION: [],
  
  // Custom Kategorien (basierend auf Namen)
  NAVBAR: [],
  FOOTER: [],
  HERO: [],
  HEADER: [],
  CTA: [],
  BLOG: [],
  TESTIMONIAL: [],
  GALLERY: [],
  FORM: [],
  PRICING: [],
  TEAM: [],
  FAQ: [],
  CONTACT: [],
  
  // Sonstige
  OTHER: [],
}

// Kategorisiere jeden Component
for (const component of allComponents) {
  const { type, name } = component
  
  // Nach Figma-Typ
  if (categorized[type]) {
    categorized[type].push(component)
  }
  
  // Nach Name (Case-insensitive)
  const nameLower = name.toLowerCase()
  
  if (nameLower.includes('navbar') || nameLower.includes('navigation')) {
    categorized.NAVBAR.push(component)
  }
  if (nameLower.includes('footer')) {
    categorized.FOOTER.push(component)
  }
  if (nameLower.includes('hero')) {
    categorized.HERO.push(component)
  }
  if (nameLower.includes('header')) {
    categorized.HEADER.push(component)
  }
  if (nameLower.includes('cta') || nameLower.includes('call-to-action')) {
    categorized.CTA.push(component)
  }
  if (nameLower.includes('blog')) {
    categorized.BLOG.push(component)
  }
  if (nameLower.includes('testimonial') || nameLower.includes('review')) {
    categorized.TESTIMONIAL.push(component)
  }
  if (nameLower.includes('gallery') || nameLower.includes('portfolio')) {
    categorized.GALLERY.push(component)
  }
  if (nameLower.includes('form') || nameLower.includes('input')) {
    categorized.FORM.push(component)
  }
  if (nameLower.includes('pricing') || nameLower.includes('price')) {
    categorized.PRICING.push(component)
  }
  if (nameLower.includes('team') || nameLower.includes('member')) {
    categorized.TEAM.push(component)
  }
  if (nameLower.includes('faq') || nameLower.includes('question')) {
    categorized.FAQ.push(component)
  }
  if (nameLower.includes('contact')) {
    categorized.CONTACT.push(component)
  }
}

// Ausgabe Kategorisierung
console.log('\nüìä Kategorisierung:')
console.log('\n**Figma Node-Typen:**')
console.log(`   - FRAME: ${categorized.FRAME.length}`)
console.log(`   - COMPONENT: ${categorized.COMPONENT.length}`)
console.log(`   - COMPONENT_SET: ${categorized.COMPONENT_SET.length}`)
console.log(`   - INSTANCE: ${categorized.INSTANCE.length}`)
console.log(`   - GROUP: ${categorized.GROUP.length}`)
console.log(`   - TEXT: ${categorized.TEXT.length}`)
console.log(`   - RECTANGLE: ${categorized.RECTANGLE.length}`)
console.log(`   - VECTOR: ${categorized.VECTOR.length}`)

console.log('\n**Semantic Kategorien:**')
console.log(`   - NAVBAR: ${categorized.NAVBAR.length}`)
console.log(`   - FOOTER: ${categorized.FOOTER.length}`)
console.log(`   - HERO: ${categorized.HERO.length}`)
console.log(`   - HEADER: ${categorized.HEADER.length}`)
console.log(`   - CTA: ${categorized.CTA.length}`)
console.log(`   - BLOG: ${categorized.BLOG.length}`)
console.log(`   - TESTIMONIAL: ${categorized.TESTIMONIAL.length}`)
console.log(`   - GALLERY: ${categorized.GALLERY.length}`)
console.log(`   - FORM: ${categorized.FORM.length}`)
console.log(`   - PRICING: ${categorized.PRICING.length}`)
console.log(`   - TEAM: ${categorized.TEAM.length}`)
console.log(`   - FAQ: ${categorized.FAQ.length}`)
console.log(`   - CONTACT: ${categorized.CONTACT.length}`)
```

---

### Phase 5: Detailed Component Analysis

F√ºr die wichtigsten Komponenten (COMPONENT, FRAME, INSTANCE) extrahiere Details:

```typescript
// 5. Analysiere Top-Level Komponenten
const topLevelComponents = allComponents.filter(c => 
  (c.type === 'COMPONENT' || c.type === 'FRAME') && 
  c.depth <= 2
)

console.log(`\nüìã Top-Level Komponenten (${topLevelComponents.length}):`)
console.log('‚ïê'.repeat(80))

for (const component of topLevelComponents) {
  console.log(`\nüì¶ ${component.name}`)
  console.log(`   - ID: ${component.id}`)
  console.log(`   - Typ: ${component.type}`)
  console.log(`   - Seite: ${component.page}`)
  console.log(`   - Pfad: ${component.path}`)
  console.log(`   - Kinder: ${component.childrenCount}`)
  
  // Lade zus√§tzliche Details
  const details = await mcp.getFigmaNode({
    fileKey: FIGMA_FILE_KEY,
    nodeId: component.id,
  })
  
  // Extrahiere Styles
  if (details.style) {
    console.log(`   - Styles:`)
    if (details.style.fills) console.log(`     - Fills: ${JSON.stringify(details.style.fills)}`)
    if (details.style.strokes) console.log(`     - Strokes: ${JSON.stringify(details.style.strokes)}`)
    if (details.style.effects) console.log(`     - Effects: ${JSON.stringify(details.style.effects)}`)
  }
  
  // Extrahiere Layout
  if (details.layoutMode) {
    console.log(`   - Layout Mode: ${details.layoutMode}`)
    console.log(`   - Primary Axis: ${details.primaryAxisAlignItems}`)
    console.log(`   - Counter Axis: ${details.counterAxisAlignItems}`)
    console.log(`   - Padding: ${JSON.stringify(details.paddingLeft)}, ${JSON.stringify(details.paddingRight)}, ${JSON.stringify(details.paddingTop)}, ${JSON.stringify(details.paddingBottom)}`)
    console.log(`   - Gap: ${details.itemSpacing}`)
  }
  
  // Extrahiere Text
  if (details.type === 'TEXT') {
    console.log(`   - Text: "${details.characters}"`)
    console.log(`   - Font: ${details.style.fontFamily} ${details.style.fontWeight}`)
    console.log(`   - Size: ${details.style.fontSize}px`)
  }
}
```

---

### Phase 6: Mapping zu Relume-Komponenten

```typescript
// 6. Mappe Figma-Komponenten zu Relume-Templates
const relumeMapping = []

// Lade alle Relume-Komponenten
const relumeComponents = await glob('relume/**/*.tsx')

for (const figmaComponent of topLevelComponents) {
  // Suche nach passender Relume-Komponente
  const possibleMatches = relumeComponents.filter(relumeFile => {
    const relumeName = path.basename(relumeFile, '.tsx')
    const figmaName = figmaComponent.name
    
    // Verschiedene Matching-Strategien
    return (
      // Exakter Name-Match
      relumeName === figmaName ||
      
      // Case-insensitive Match
      relumeName.toLowerCase() === figmaName.toLowerCase() ||
      
      // Partial Match (z.B. "Hero1" matched "Hero-1")
      relumeName.replace(/[^a-zA-Z0-9]/g, '') === figmaName.replace(/[^a-zA-Z0-9]/g, '') ||
      
      // Kategorie-Match
      relumeFile.includes(figmaComponent.page)
    )
  })
  
  if (possibleMatches.length > 0) {
    relumeMapping.push({
      figma: figmaComponent,
      relume: possibleMatches[0],
      matchType: 'exact',
    })
    console.log(`   ‚úÖ ${figmaComponent.name} ‚Üí ${possibleMatches[0]}`)
  } else {
    relumeMapping.push({
      figma: figmaComponent,
      relume: null,
      matchType: 'none',
    })
    console.log(`   ‚ö†Ô∏è ${figmaComponent.name} ‚Üí Keine Relume-Komponente gefunden`)
  }
}

console.log(`\nüìä Mapping-Ergebnisse:`)
console.log(`   - Erfolgreich gemappt: ${relumeMapping.filter(m => m.relume).length}`)
console.log(`   - Nicht gemappt: ${relumeMapping.filter(m => !m.relume).length}`)
```

---

### Phase 7: Export & Dokumentation

```typescript
// 7. Exportiere vollst√§ndiges Inventar
const inventory = {
  meta: {
    generatedAt: new Date().toISOString(),
    figmaFileKey: FIGMA_FILE_KEY,
    figmaFileName: figmaFile.name,
    figmaVersion: figmaFile.version,
    totalComponents: allComponents.length,
  },
  
  // Alle Komponenten
  allComponents,
  
  // Kategorisierung
  categorized,
  
  // Top-Level Komponenten
  topLevelComponents,
  
  // Relume-Mapping
  relumeMapping,
  
  // Statistiken
  statistics: {
    byType: Object.entries(categorized)
      .filter(([key]) => !['OTHER'].includes(key))
      .map(([type, items]) => ({ type, count: items.length }))
      .sort((a, b) => b.count - a.count),
    
    byPage: figmaFile.document.children.map(page => ({
      name: page.name,
      count: allComponents.filter(c => c.page === page.name).length,
    })),
    
    byDepth: Array.from({ length: 10 }, (_, depth) => ({
      depth,
      count: allComponents.filter(c => c.depth === depth).length,
    })).filter(item => item.count > 0),
  },
}

// Speichere als JSON
await fs.writeFile(
  'FIGMA_INVENTORY.json',
  JSON.stringify(inventory, null, 2)
)

// Generiere Markdown-Dokumentation
const markdown = `
# Figma Components Inventory

**Generiert:** ${inventory.meta.generatedAt}
**Figma File:** ${inventory.meta.figmaFileName}
**Version:** ${inventory.meta.figmaVersion}

---

## üìä √úbersicht

- **Gesamt:** ${inventory.meta.totalComponents} Komponenten
- **Seiten:** ${inventory.statistics.byPage.length}
- **Max. Tiefe:** ${Math.max(...inventory.statistics.byDepth.map(d => d.depth))}

---

## üì¶ Komponenten nach Typ

${inventory.statistics.byType.map(({ type, count }) => 
  `### ${type} (${count})\n` +
  categorized[type].slice(0, 10).map(c => 
    `- \`${c.name}\` (${c.page})`
  ).join('\n') +
  (categorized[type].length > 10 ? `\n... und ${categorized[type].length - 10} weitere` : '')
).join('\n\n')}

---

## üìÑ Komponenten nach Seite

${inventory.statistics.byPage.map(({ name, count }) => 
  `### ${name} (${count} Komponenten)`
).join('\n\n')}

---

## üîó Figma ‚Üî Relume Mapping

### ‚úÖ Erfolgreich gemappt (${relumeMapping.filter(m => m.relume).length})

${relumeMapping
  .filter(m => m.relume)
  .map(m => `- **${m.figma.name}** ‚Üí \`${m.relume}\``)
  .join('\n')}

### ‚ö†Ô∏è Nicht gemappt (${relumeMapping.filter(m => !m.relume).length})

${relumeMapping
  .filter(m => !m.relume)
  .map(m => `- **${m.figma.name}** (${m.figma.page})`)
  .join('\n')}

---

## üöÄ N√§chste Schritte

1. Review nicht gemappter Komponenten
2. Generiere fehlende Relume-Templates
3. Starte Block-Generierung mit \`build-blocks-full\`
4. Registriere alle Blocks in PayloadCMS

---

**Vollst√§ndiges Inventar:** \`FIGMA_INVENTORY.json\`
`

await fs.writeFile('FIGMA_INVENTORY.md', markdown)

console.log('\n‚úÖ Inventar exportiert:')
console.log('   - FIGMA_INVENTORY.json')
console.log('   - FIGMA_INVENTORY.md')
```

---

## üìä Ausgabe-Format

### Console Output
```
üîç Figma Components Erfassung gestartet...

‚úÖ Figma MCP Server verbunden
   - File Key: abc123xyz
   - Access Token: ‚úì

üìä Figma-File geladen:
   - Name: Elisa Website Design
   - Version: 42
   - Last Modified: 2024-01-15T10:30:00Z

üìÑ Scanne Seite: Homepage
   ‚úÖ 142 Komponenten gefunden

üìÑ Scanne Seite: About
   ‚úÖ 87 Komponenten gefunden

üìÑ Scanne Seite: Services
   ‚úÖ 113 Komponenten gefunden

... (weitere Seiten)

‚úÖ 1456 Komponenten erfasst!

üìä Kategorisierung:

**Figma Node-Typen:**
   - FRAME: 324
   - COMPONENT: 187
   - INSTANCE: 589
   - GROUP: 156
   - TEXT: 200

**Semantic Kategorien:**
   - HERO: 12
   - NAVBAR: 8
   - FOOTER: 6
   - CTA: 45
   - BLOG: 32
   - TESTIMONIAL: 18
   - GALLERY: 15
   - FORM: 23
   - PRICING: 14
   - TEAM: 10
   - FAQ: 8
   - CONTACT: 12

üìã Top-Level Komponenten (187):
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üì¶ Hero Section - Homepage
   - ID: 1:234
   - Typ: FRAME
   - Seite: Homepage
   - Pfad: Homepage > Hero Section - Homepage
   - Kinder: 8
   - Layout Mode: VERTICAL
   - Primary Axis: CENTER
   - Gap: 32

... (weitere Komponenten)

üîó Relume-Mapping:

   ‚úÖ Hero Section - Homepage ‚Üí relume/Header/Header1.tsx
   ‚úÖ Feature Grid ‚Üí relume/Layout/Layout42.tsx
   ‚ö†Ô∏è Custom Newsletter Form ‚Üí Keine Relume-Komponente gefunden
   
... (weitere Mappings)

üìä Mapping-Ergebnisse:
   - Erfolgreich gemappt: 134
   - Nicht gemappt: 53

‚úÖ Inventar exportiert:
   - FIGMA_INVENTORY.json
   - FIGMA_INVENTORY.md

üéâ Vollst√§ndige Figma-Erfassung abgeschlossen!
```

---

## üéØ Verwendung

**F√ºhre diesen Command aus, um ALLE Figma-Komponenten zu erfassen:**

```bash
cursor> Fetch ALL Figma Components
```

**Oder als Teil des Build-Workflows:**

```typescript
// 1. Figma-Komponenten erfassen
await fetchAllFigmaComponents()

// 2. Mit Relume-Komponenten abgleichen
await mapToRelumeTemplates()

// 3. Blocks generieren
await generateAllBlocks()
```

---

‚úÖ **Vollst√§ndige Figma-Erfassung ohne Ausschl√ºsse oder Limitierungen!**
