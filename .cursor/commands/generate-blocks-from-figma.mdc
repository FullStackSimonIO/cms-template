---
title: 'Generate Blocks from Figma'
description: 'Generiert PayloadCMS Blocks aus verbleibenden Figma-Komponenten (OHNE Navbar, Footer, Heroes)'
---

## ğŸ¯ Ziel
Generiere Blocks **nur** aus den verbleibenden Komponenten:
- **NICHT** Navbar (bereits als Global)
- **NICHT** Footer (bereits als Global)
- **NICHT** Heroes (bereits unter /src/heroes/)
- **NUR** Layout, CTA, Contact, Testimonials, etc. als Blocks

---

## ğŸ“¦ Workflow

### Schritt 1: Verbleibende Komponenten filtern

```typescript
// 1. Lade FIGMA_INVENTORY.json
const inventory = JSON.parse(
  await fs.readFile('FIGMA_INVENTORY.json', 'utf-8')
)

console.log('ğŸ“¦ Filtere Komponenten fÃ¼r Block-Generierung...')

// Filtere Komponenten (OHNE Navbar, Footer, Hero)
const blockCategories = Object.entries(inventory.categorized)
  .filter(([category, _]) => 
    !['Navbar', 'Footer', 'Hero', 'Uncategorized'].includes(category)
  )

const totalBlockComponents = blockCategories.reduce(
  (sum, [_, items]) => sum + items.length, 
  0
)

console.log(`\nâœ… ${totalBlockComponents} Komponenten fÃ¼r Blocks:`)
blockCategories.forEach(([category, items]) => {
  console.log(`   - ${category}: ${items.length} Komponenten`)
})
```

---

### Schritt 2: Block-Generierungs-Plan

```typescript
// 2. Erstelle Generierungs-Plan
const generationPlan = []

for (const [category, components] of blockCategories) {
  for (const component of components) {
    // Finde passendes Relume-Template
    const relumeTemplates = await glob(`relume/${category}/*.tsx`)
    
    const matchedTemplate = relumeTemplates.find(template => {
      const templateName = path.basename(template, '.tsx')
      const normalizedComponentName = component.name
        .replace(/[^a-zA-Z0-9]/g, '')
        .toLowerCase()
      const normalizedTemplateName = templateName
        .replace(/[^a-zA-Z0-9]/g, '')
        .toLowerCase()
      
      return normalizedTemplateName.includes(normalizedComponentName) ||
             normalizedComponentName.includes(normalizedTemplateName)
    })
    
    const templateToUse = matchedTemplate || relumeTemplates[0]
    
    if (!templateToUse) {
      console.warn(`âš ï¸ Kein Template fÃ¼r ${component.name} (${category})`)
      continue
    }
    
    generationPlan.push({
      figmaComponent: component,
      category: category,
      blockName: generateBlockName(component.name),
      relumeTemplate: templateToUse,
    })
  }
}

console.log(`\nğŸ“‹ Generierungs-Plan: ${generationPlan.length} Blocks`)

// Helper
function generateBlockName(figmaName) {
  // "CTA Section 1" â†’ "CtaSection1"
  return figmaName
    .split(/[\s\-_]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
    .replace(/[^a-zA-Z0-9]/g, '')
}
```

---

### Schritt 3: Blocks generieren

```typescript
// 3. Generiere Blocks
let successCount = 0
let failCount = 0
const generatedBlocks = []

for (const plan of generationPlan) {
  try {
    const blockPath = `src/blocks/${plan.category}/${plan.blockName}`
    
    await fs.mkdir(blockPath, { recursive: true })
    
    console.log(`\nğŸ—ï¸ Generiere ${plan.category}/${plan.blockName}...`)
    
    // 1. Lade Relume-Template
    const relumeTemplate = await fs.readFile(plan.relumeTemplate, 'utf-8')
    
    // 2. Analysiere Figma-Komponente
    const figmaDetails = await mcp.getFigmaNode({
      fileKey: FIGMA_FILE_KEY,
      nodeId: plan.figmaComponent.id,
    })
    
    // 3. Generiere Component.tsx
    const componentCode = await generateComponentTSX({
      blockName: plan.blockName,
      category: plan.category,
      relumeTemplate,
      figmaDetails,
    })
    
    await fs.writeFile(
      `${blockPath}/Component.tsx`,
      componentCode
    )
    
    // 4. Generiere config.ts
    const configCode = await generateConfigTS({
      blockName: plan.blockName,
      category: plan.category,
      figmaComponent: plan.figmaComponent,
    })
    
    await fs.writeFile(
      `${blockPath}/config.ts`,
      configCode
    )
    
    // 5. Generiere index.ts
    const indexCode = `export { ${plan.blockName} } from './Component'
export { ${plan.blockName}Block } from './config'
`
    
    await fs.writeFile(
      `${blockPath}/index.ts`,
      indexCode
    )
    
    successCount++
    generatedBlocks.push(plan)
    console.log(`   âœ… ${plan.blockName}`)
    
  } catch (error) {
    failCount++
    console.error(`   âŒ ${plan.blockName}: ${error.message}`)
  }
}

console.log(`\nğŸ“Š Generierungs-Ergebnis:`)
console.log(`   âœ… Erfolgreich: ${successCount}`)
console.log(`   âŒ Fehlgeschlagen: ${failCount}`)

// Helpers
async function generateComponentTSX({ blockName, category, relumeTemplate, figmaDetails }) {
  // Basis: Relume-Template
  let componentCode = relumeTemplate
  
  // Ersetze Komponentennamen
  componentCode = componentCode.replace(
    /export\s+(const|function)\s+\w+/,
    `export const ${blockName}`
  )
  
  // FÃ¼ge Payload-Typen hinzu
  componentCode = componentCode.replace(
    /import.*\n/,
    match => match + `import type { ${blockName}Block } from '@/payload-types'\n`
  )
  
  // Interface anpassen
  componentCode = componentCode.replace(
    /interface\s+\w+Props/,
    `interface ${blockName}Props`
  )
  
  // Props mit block
  componentCode = componentCode.replace(
    /{\s*([^}]+)\s*}/,
    `{ block }: { block: ${blockName}Block }`
  )
  
  // Destrukturiere block
  const fields = extractFieldsFromConfig(figmaDetails)
  componentCode = componentCode.replace(
    /const\s+{[^}]*}/,
    `const { ${fields.join(', ')} } = block || {}`
  )
  
  return componentCode
}

async function generateConfigTS({ blockName, category, figmaComponent }) {
  const slug = `${category.toLowerCase()}${blockName}`
  
  return `
import type { Block } from 'payload/types'

export const ${blockName}Block: Block = {
  slug: '${slug}',
  labels: {
    singular: '${blockName}',
    plural: '${blockName} BlÃ¶cke',
  },
  fields: [
    {
      name: 'title',
      type: 'text',
      label: 'Titel',
      admin: {
        description: 'HauptÃ¼berschrift des Blocks',
      },
    },
    {
      name: 'description',
      type: 'textarea',
      label: 'Beschreibung',
      admin: {
        description: 'Kurzbeschreibung',
      },
    },
    {
      name: 'content',
      type: 'richText',
      label: 'Inhalt',
      admin: {
        description: 'Formatierter Text-Inhalt',
      },
    },
    {
      name: 'media',
      type: 'upload',
      relationTo: 'media',
      label: 'Bild/Video',
      admin: {
        description: 'Medien-Element fÃ¼r diesen Block',
      },
    },
    {
      name: 'primaryCTA',
      type: 'group',
      label: 'Haupt-Button',
      fields: [
        {
          name: 'label',
          type: 'text',
          label: 'Button-Text',
        },
        {
          name: 'url',
          type: 'text',
          label: 'URL',
        },
        {
          name: 'newTab',
          type: 'checkbox',
          label: 'In neuem Tab Ã¶ffnen',
          defaultValue: false,
        },
      ],
    },
  ],
  admin: {
    group: '${category}',
    description: 'Aus Figma-Komponente "${figmaComponent.name}" generiert',
  },
}
`
}

function extractFieldsFromConfig(figmaDetails) {
  // Intelligente Field-Extraktion basierend auf Figma-Struktur
  const fields = ['title']
  
  // PrÃ¼fe auf verschiedene Elemente
  if (figmaDetails.children) {
    const hasImages = figmaDetails.children.some(c => 
      c.type === 'RECTANGLE' || /image|img|photo/i.test(c.name)
    )
    const hasText = figmaDetails.children.some(c => c.type === 'TEXT')
    const hasButtons = figmaDetails.children.some(c => 
      /button|btn|cta/i.test(c.name)
    )
    
    if (hasText) fields.push('description', 'content')
    if (hasImages) fields.push('media')
    if (hasButtons) fields.push('primaryCTA', 'secondaryCTA')
  }
  
  return [...new Set(fields)]
}
```

---

### Schritt 4: Zentrale Registrierung

```typescript
// 4. Zentrale Export-Datei
const exportsCode = generatedBlocks.map(block =>
  `export { ${block.blockName}, ${block.blockName}Block } from './${block.category}/${block.blockName}'`
).join('\n')

await fs.writeFile('src/blocks/index.ts', exportsCode)
console.log('\nâœ… Zentrale Exports: src/blocks/index.ts')

// 5. Pages Collection aktualisieren
const pagesConfigPath = 'src/collections/Pages/config.ts'
const pagesConfig = await fs.readFile(pagesConfigPath, 'utf-8')

// Imports
const blockImports = generatedBlocks.map(block =>
  `  ${block.blockName}Block,`
).join('\n')

// Blocks-Array
const blocksArray = generatedBlocks.map(block =>
  `    ${block.blockName}Block,`
).join('\n')

const updatedPagesConfig = pagesConfig.replace(
  /blocks:\s*\[[\s\S]*?\]/,
  `blocks: [\n${blocksArray}\n  ]`
)

await fs.writeFile(pagesConfigPath, updatedPagesConfig)
console.log(`âœ… Pages Collection: ${generatedBlocks.length} Blocks registriert`)

// 6. PageRenderer aktualisieren
const pageRendererPath = 'src/components/PageRenderer/index.tsx'
let pageRenderer = await fs.readFile(pageRendererPath, 'utf-8')

// Component-Imports
const componentImports = generatedBlocks.map(block =>
  `  ${block.blockName},`
).join('\n')

// Mapping
const componentMapping = generatedBlocks.map(block => {
  const slug = `${block.category.toLowerCase()}${block.blockName}`
  return `  '${slug}': ${block.blockName},`
}).join('\n')

pageRenderer = pageRenderer.replace(
  /const blockComponents = \{[\s\S]*?\}/,
  `const blockComponents = {\n${componentMapping}\n}`
)

await fs.writeFile(pageRendererPath, pageRenderer)
console.log(`âœ… PageRenderer: ${generatedBlocks.length} Komponenten gemappt`)
```

---

### Schritt 5: Dokumentation

```typescript
// 7. Generierungs-Report
const report = {
  meta: {
    generatedAt: new Date().toISOString(),
    totalBlocks: generatedBlocks.length,
    successRate: ((successCount / generationPlan.length) * 100).toFixed(1) + '%',
  },
  blocks: generatedBlocks.map(block => ({
    name: block.blockName,
    category: block.category,
    figmaComponent: block.figmaComponent.name,
    figmaPage: block.figmaComponent.page,
  })),
  byCategory: Object.entries(
    generatedBlocks.reduce((acc, block) => {
      acc[block.category] = (acc[block.category] || 0) + 1
      return acc
    }, {})
  ).map(([category, count]) => ({ category, count })),
}

await fs.writeFile(
  'BLOCKS_GENERATION_REPORT.json',
  JSON.stringify(report, null, 2)
)

const markdown = `
# PayloadCMS Blocks - Generierungs-Report

**Generiert:** ${report.meta.generatedAt}
**Anzahl Blocks:** ${report.meta.totalBlocks}
**Erfolgsrate:** ${report.meta.successRate}

---

## ğŸ“Š Blocks nach Kategorie

${report.byCategory.map(({ category, count }) =>
  `### ${category} (${count} Blocks)\n\n` +
  generatedBlocks
    .filter(b => b.category === category)
    .map(b => `- **${b.blockName}** â† \`${b.figmaComponent.name}\` (${b.figmaComponent.page})`)
    .join('\n')
).join('\n\n')}

---

## ğŸ“ Generierte Dateien

\`\`\`
src/blocks/
${Object.keys(
  generatedBlocks.reduce((acc, block) => {
    acc[block.category] = true
    return acc
  }, {})
).map(category =>
  `â”œâ”€â”€ ${category}/\n` +
  generatedBlocks
    .filter(b => b.category === category)
    .slice(0, 3)
    .map(b => `â”‚   â”œâ”€â”€ ${b.blockName}/\nâ”‚   â”‚   â”œâ”€â”€ Component.tsx\nâ”‚   â”‚   â”œâ”€â”€ config.ts\nâ”‚   â”‚   â””â”€â”€ index.ts`)
    .join('\n')
).join('\n')}
â””â”€â”€ index.ts
\`\`\`

---

## âœ… Registrierung

- âœ… Zentrale Exports: \`src/blocks/index.ts\`
- âœ… Pages Collection: \`src/collections/Pages/config.ts\`
- âœ… PageRenderer: \`src/components/PageRenderer/index.tsx\`

---

## ğŸš€ NÃ¤chste Schritte

1. **TypeScript Validierung**
   \`\`\`bash
   npm run type-check
   \`\`\`

2. **Build Test**
   \`\`\`bash
   npm run build
   \`\`\`

3. **Dev-Server starten**
   \`\`\`bash
   npm run dev
   \`\`\`

4. **Admin-Panel testen**
   - http://localhost:3000/admin/collections/pages
   - PrÃ¼fe: ${report.meta.totalBlocks} Blocks verfÃ¼gbar
`

await fs.writeFile('BLOCKS_GENERATION_REPORT.md', markdown)

console.log('\nğŸ“„ Dokumentation erstellt:')
console.log('   - BLOCKS_GENERATION_REPORT.json')
console.log('   - BLOCKS_GENERATION_REPORT.md')
```

---

## ğŸ‰ Erfolgsmeldung

```typescript
console.log('\n' + '='.repeat(80))
console.log('ğŸ“¦ BLOCK-GENERIERUNG ABGESCHLOSSEN!')
console.log('='.repeat(80))
console.log(`
âœ… Generiert:
   - ${successCount} Blocks erfolgreich
   ${failCount > 0 ? `- ${failCount} Fehler` : ''}
   - ${Object.keys(report.byCategory).length} Kategorien

ğŸ“ Struktur:
   - src/blocks/{Category}/{BlockName}/Component.tsx
   - src/blocks/{Category}/{BlockName}/config.ts
   - src/blocks/{Category}/{BlockName}/index.ts
   - src/blocks/index.ts (zentrale Exports)

âœ… Registriert in:
   - Pages Collection (${successCount} Blocks)
   - PageRenderer (${successCount} Komponenten)

ğŸ“„ Dokumentation:
   - BLOCKS_GENERATION_REPORT.json
   - BLOCKS_GENERATION_REPORT.md

ğŸ¯ WICHTIG:
   âœ… Navbar â†’ Bereits als Global generiert
   âœ… Footer â†’ Bereits als Global generiert
   âœ… Heroes â†’ Bereits unter /src/heroes/
   âœ… Blocks â†’ Nur verbleibende Komponenten (${successCount})

ğŸš€ NÃ¤chste Schritte:
   1. npm run type-check
   2. npm run build
   3. npm run dev
   4. Teste im Admin-Panel!
`)
console.log('='.repeat(80))
```

---

## âœ… Checkliste

- [ ] Nur verbleibende Komponenten generiert (OHNE Navbar, Footer, Heroes)
- [ ] Alle Blocks unter `src/blocks/{Category}/{BlockName}/`
- [ ] Zentrale `src/blocks/index.ts` erstellt
- [ ] Pages Collection aktualisiert
- [ ] PageRenderer aktualisiert
- [ ] TypeScript fehlerfrei
- [ ] Admin-Panel zeigt alle Blocks

---

âœ… **Blocks aus Figma generiert - OHNE Navbar, Footer und Heroes!**
